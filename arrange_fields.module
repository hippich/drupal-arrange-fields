<?php
// $Id$


/**
 * Implementation of hook_menu().
 *
 * @return array
 */
function arrange_fields_menu() {
  $items = array();
  
  $items["arrange-fields/%"] = array(
    "title" => t("Arrange fields - Form"),
    "page callback" => "arrange_fields_display_form",
    "page arguments" => array(1),
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_CALLBACK,
  );
  
  $items["arrange-fields/webform/%"] = array(
    "title" => t("Arrange fields - Webform"),
    "page callback" => "arrange_fields_display_webform",
    "page arguments" => array(2),
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_CALLBACK,
  );  

  $items["arrange-fields/other/%"] = array(
    "title" => t("Arrange fields - Other Forms"),
    "page callback" => "arrange_fields_display_otherform",
    "page arguments" => array(2),
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_CALLBACK,
  );  
  
  $items["admin/content/types/arrange-fields"] = array(
    "title" => t("Arrange form fields"),
    "page callback" => "arrange_fields_display_main",
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_LOCAL_TASK,
    "weight" => 5,
  );
  
  $items["admin/settings/arrange-fields"] = array(
    "title" => t("Arrange fields"),
    "description" => t("Arrange fields and components on your forms."),
    "page callback" => "arrange_fields_display_main",
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_NORMAL_ITEM,
  );
  
  // Admin settings menu...
  $items["admin/settings/arrange-fields"] = array(
    "title" => t("Arrange fields"),
    "description" => t("Arrange fields and components on your forms."),
    "page callback" => "arrange_fields_display_main",
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_NORMAL_ITEM,
  );
  $items["admin/settings/arrange-fields/forms"] = array(
    "title" => t("Forms"),
    "type" => MENU_DEFAULT_LOCAL_TASK,
    "weight" => 1,
  );
  $items["admin/settings/arrange-fields/settings"] = array(
    "title" => t("Settings"),
    "page callback" => "drupal_get_form",
    "page arguments" => array("arrange_fields_settings_form"),
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_LOCAL_TASK,
    "weight" => 2,
  );
  
  
  
  
  // CCK/Content type menu......
  // Get a list of content types and create menu hooks for them.
  foreach (node_get_types() as $type) {
    
    $type_name = $type->type;
    $content_type = content_types($type_name);
    $type_url_str = $content_type['url_str'];
    
    $items["admin/content/node-type/$type_url_str/arrange-fields"] = array(
      "title" => "Arrange fields",
      "page callback" => "arrange_fields_display_form",
      "page arguments" => array($type_name),
      "access arguments" => array("administer arrange fields"),
      "type" => MENU_LOCAL_TASK,
      "weight" => 3,
    );
    
  
  }

   
  // If webform has been installed, create the menu hooks so it ties in
  // nicely with webform.  
  if ($GLOBALS["arrange_fields_webform_installed"]) {
    $items["node/%/edit/arrange-fields"] = array(
      "title" => "Arrange fields",
      "page callback" => "arrange_fields_display_webform",
      "page arguments" => array(1),
      "access arguments" => array("administer arrange fields"),
      "type" => MENU_LOCAL_TASK,
      "weight" => 3,
    );
  }  
    
  

  // Menu hooks for the two popups used with CCK fields...
  $items["arrange-fields/popup-edit-field"] = array(
    "title" => t("Arrange fields - Form"),
    "page callback" => "arrange_fields_popup_edit_field",
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_CALLBACK,
  );  
  $items["arrange-fields/popup-close-window"] = array(
    "title" => t("Arrange fields - Form"),
    "page callback" => "arrange_fields_popup_close_window",
    "access arguments" => array("administer arrange fields"),
    "type" => MENU_CALLBACK,
  );  
  
  return $items;
}


function arrange_fields_perm() {
  return array("administer arrange fields");
}

/**
 * This function returns a form which we will use to configure
 * the arrange_fields module.  It is called
 * from menu item:  admin/settings/arrange-fields/settings
 *
 * @return array
 */
function arrange_fields_settings_form() {
  $form = array();

  $form["arrange_fields_other_form_ids"] = array(
    "#type" => "textarea",
    "#title" => "Additional form_id's",
    "#default_value" => variable_get("arrange_fields_other_form_ids", ""),
    "#description" => "Enter any additional form_id's you would like to be
                      able to arrange, <strong>one per line</strong>.  
                      Be aware that
                      this module (Arrange Fields) may not be able to
                      arrange forms with complex structures.  Also, form_ids that
                      are longer than 100 characters are allowed, but may not work 
                      correctly if the first 100 characters are identical between two
                      or more ids.
                      <br>
                      After you enter complete form_id's here and hit Save,
                      you will be able to arrange them by clicking on them
                      at the bottom of the " . l("Arrange Fields admin settings page", "admin/settings/arrange-fields") . ".
                      <br>
                      Example: <br>
                      &nbsp;&nbsp;<strong>user_register</strong>
                      <br>
                      &nbsp;&nbsp;<strong>my_custom_form_id_1</strong>
                      ",
  );
  
  return system_settings_form($form);
}



/**
 * In this function, we are going to add div's around elements we wish to make
 * draggable on the page.  The jQuery can then grab onto those divs to make
 * them draggable.
 *
 * @param array $form
 * @param string $form_type
 * @param bool $disable_buttons
 */
function arrange_fields_add_draggable_wrappers(&$form, $form_type, $disable_buttons = FALSE) {

  if ($form_type == "webform") {
    return arrange_fields_add_draggable_webform_wrappers($form, $disable_buttons);
  }

  // If we are arranging the buttons, then disable these buttons!
  if ($disable_buttons) {
    if (is_array($form["buttons"])) {
      $form["buttons"]["submit"]["#attributes"]["disabled"] = "disabled";
      $form["buttons"]["submit"]["#attributes"]["class"] .= " disabled-button ";
      $form["buttons"]["preview"]["#attributes"]["disabled"] = "disabled";
      $form["buttons"]["preview"]["#attributes"]["class"] .= " disabled-button ";
    }
  }

  // Go through every element in $form to find which items need to be draggable.
  foreach ($form as $field => $value) {

    // Kludgy method of figuring out if this field should be draggable or not
    // (basically, if it is a field at all).  I am positive there is probably
    // a better, cleaner way to do this, but at the moment I can't figure
    // out what it is.
    if (is_array($form[$field]) && 
        ($form[$field]["#type"] == "textfield" 
        || $form[$field][0]["#type"] == "text_textfield"
        || $form[$field][0]["#type"] == "text_textarea"
        || strstr($form[$field][0]["#type"], "image")
        || $form[$field]["body"]["#type"] == "textarea"
        || strstr($form[$field]["#type"], "option") 
        || strstr($form[$field]["#type"], "_widget") 
        || strstr($form[$field][0]["#type"], "_widget") 
        || strstr($form[$field]["#type"], "nodereference") 
        || strstr($form[$field]["#type"], "userreference") 
        || strstr($form[$field][0]["#type"], "date") 
        || $field == "taxonomy"  
        || $field == "buttons" 
        || substr($field, 0, 6) == "field_"
        || (isset($form[$field]["#type"]) 
            && $form[$field]["#type"] != "hidden")
        )) {
      
          
      $field_type = $form[$field]["#type"];
      $edit_link = "";
      $edit_link = "<div class='arrange-fields-control-handle' 
                        style='font-size: 0.8em;'>";
      // If this is a CCK type, give it an extra option.
      if ($GLOBALS["arrange_fields_editing_type"] == $form_type 
        && $form_type != ""
        && (substr($field, 0, 6) == "field_")
       ) 
      {
          $edit_link .= "<a href='javascript: arrangeFieldsPopupEditField(\"$form_type\", \"$field\");'>cck</a>";
      }      

      $edit_link .= "<span class='arrange-fields-handle-region'> &nbsp; &nbsp; </span>
                      <a href='javascript: arrangeFieldsPopupConfigField(\"$field\",\"$field_type\");' class='arrange-fields-config-link' 
                      title='Configure this field'>&nbsp;</a>";
      $edit_link .= "</div>";
      

      $css_class = "draggable-form-item";
      $css_id = "edit-$field-draggable-wrapper";

      // Are we dealing with a fieldset?     
      if ($form[$field]["#type"] == "fieldset") {
        // Fieldsets get an extra css_class and the ID changes.
        $css_class .= " draggable-form-item-fieldset";
        $css_id = "edit-$field-fieldset-draggable-wrapper";        
      }
      
      // Set the prefix and suffix for this field such that we 
      // wrap a div around it which the jquery can lock onto later to
      // make it draggable.
      $form[$field]["#prefix"] .= "<div id='$css_id' class='$css_class'>$edit_link";
      $form[$field]["#suffix"] .= "</div>"; 
     
      // If the field is a button, and we have chosen to disable buttons, then
      // disable this one.
      if ($form[$field]["#type"] == "submit" || $form[$field]["#type"] == "button") {
        if ($disable_buttons) {
            $form[$field]["#attributes"]["disabled"] = "disabled";
            $form[$field]["#attributes"]["class"] .= " disabled-button ";
        }        
      }
       
    }
    
  }
  
  // We set this global so later on we can easily tell if we've already performed this opperation.
  $GLOBALS["arrange_fields_added_wrappers_" . $form["form_id"]["#value"]] =  TRUE;    
}


/**
 * Similar to add_draggable_wrappers, but specially modified when dealing with webform
 * fields.
 *
 */
function arrange_fields_add_draggable_webform_wrappers(&$form, $disable_buttons = FALSE) {
  
  $form["submit"]["#prefix"] = "<div id='edit-buttons-wrapper' class='draggable-form-item'>";
  $form["submit"]["#suffix"] = "</div>";

  // If we are arranging the buttons, then disable these buttons!
  if ($disable_buttons) {
    $form["submit"]["#attributes"]["disabled"] = "disabled";
    $form["submit"]["#attributes"]["class"] .= " disabled-button ";
  }
  
  
  // Go through every element in $form to find which items need to be draggable.
  foreach ($form["submitted"] as $field => $value) {

    // Almost everything in $form["submitted"] is a field which we want to make draggable.
    if (is_array($value)) {
      
      if ($value["#type"] == "fieldset") {
        $form["submitted"][$field]["#prefix"] .= "<div id='edit-$field-fieldset-wrapper' class='draggable-form-item draggable-form-item-fieldset'>";
        $form["submitted"][$field]["#suffix"] .= "</div>";                
      }
      else {

        $field_type = "";  // nothing for now.  May get used later.
        
        $edit_link = "";
        $edit_link = "<div class='arrange-fields-control-handle' 
                          style='font-size: 0.8em;'>";
        $edit_link .= "<span class='arrange-fields-handle-region'> &nbsp; &nbsp; </span>
                        <a href='javascript: arrangeFieldsPopupConfigField(\"$field\", \"$field_type\");' class='arrange-fields-config-link' 
                        title='Configure this field'>&nbsp;</a>";
        
        $edit_link .= "</div>";        
        
        $form["submitted"][$field]["#prefix"] .= "<div id='edit-$field-draggable-wrapper' class='draggable-form-item'>$edit_link";
        $form["submitted"][$field]["#suffix"] .= "</div>"; 
      }
      
    }
    
  }
  
  // We set this global so later on we can easily tell if we've already performed this opperation.
  $GLOBALS["arrange_fields_added_wrappers_" . $form["form_id"]["#value"]] =  TRUE;    
}


/**
 * This function, which is meant to be displayed in the popup, will just take
 * CCK's field_edit_form and display it for us.  This is to make it more
 * convienent for the user, so they do not have to go to another page.
 *
 * @return string
 */
function arrange_fields_popup_edit_field() {
  
  $type_name = $_REQUEST["type_name"];
  $field_name = $_REQUEST["field"];
  
  // Make sure this CCK include has been loaded.
  module_load_include('inc', 'content', 'includes/content.admin');
  
  $GLOBALS["arrange_fields_editing_field"] = TRUE;  
  $rtn = drupal_get_form('content_field_edit_form', $type_name, $field_name);  
  
  return $rtn;
}


/**
 * After the popup_edit_field has been submitted, the user comes to this page,
 * which simply instructs them to click a button which will make the opener page
 * save itself.  This is necessary, or the changes the user made in the popup
 * will not be reflected on the page!
 *
 * @return string
 */
function arrange_fields_popup_close_window() {
  drupal_add_js(drupal_get_path("module", "arrange_fields") . "/js/arrange_fields.js");    
  
  $rtn .= "<div style='text-align: center;'>
            <input type='button' value='" . t("Close and Save/Reload Main Window") . "'
            onClick='arrangeFieldsClosePopup()'>
           </div>";
  
  return $rtn;
}



/**
 * Implementation of hook_form_alter().
 *
 */
function arrange_fields_form_alter(&$form, &$form_state, $form_id) {

  $form_type = $GLOBALS["arrange_fields_editing_type"];
  if ($GLOBALS["arrange_fields_editing"] == $form_id) {
    // meaning, we are arranging the fields on the current form_id...
    // Let's unset the various elements which will just get in the
    // way of the fields.
    unset($form["#submit"]);
    
    $form["#attributes"]["class"] = "arrange-fields-container";
    
    if (!$GLOBALS["arrange_fields_added_wrappers_" . $form["form_id"]["#value"]]) {
      arrange_fields_add_draggable_wrappers($form, $form_type, TRUE);
    }
  }

  // Do we have position data for the content type (form) currently being displayed?
  // If we do, then let's add styles to the page which contain the position data.
  if ($position_data = variable_get("arrange_fields_position_data_$form_id", FALSE)) {

    if (strpos($form_id, "webform_client_form") === 0) {
      $form_type = "webform";
    }
    
    // If this is a webform, and we are looking at submission data, then we do not want to try to
    // arrange any fields.  Doing so (at least at the moment) does not look right.
    if ($form_type == "webform" && is_array($form["submission_info"]) && $form["submission_info"]["#type"] == "fieldset") {
      return;
    }
    
    drupal_add_css(drupal_get_path("module", "arrange_fields") . "/css/arrange_fields.css");    
    drupal_add_js(drupal_get_path("module", "arrange_fields") . "/js/arrange_fields_node_edit.js");    

    $form["#attributes"]["class"] .= " arrange-fields-container ";
    
    if (!$GLOBALS["arrange_fields_added_wrappers_" . $form["form_id"]["#value"]]) {
      arrange_fields_add_draggable_wrappers($form, $form_type);
    }
      
    // Let's go through and assign the positions.
    $jsConfigArray = array();
    $css_markup = "";
    $lines = explode(";", $position_data);
    foreach ($lines as $line) {
      if (trim($line) == "") continue; // skip blanks
      
      $temp = explode(",", $line);
      $wrapper_id = trim($temp[0]);
      $pos_top = trim($temp[1]);
      $pos_left = trim($temp[2]);
      $element_type = trim($temp[3]);
      $width = trim($temp[4]);
      $height = trim($temp[5]);
      $wrapper_width = trim($temp[6]);
      $wrapper_height = trim($temp[7]);
      $label_display = trim($temp[8]);
      $label_vertical_align = trim($temp[9]);
      
      if ($wrapper_id == "~~maxBottom~~") {
        // This is actually the height of the container.  Let's set that,
        // then continue.
        $css_markup .= " .arrange-fields-container{
                      height: $pos_top;
                        }";
        continue;
      }
      
      $jsConfigArray[$wrapper_id]["wrapperWidth"] = $wrapper_width;
      $jsConfigArray[$wrapper_id]["wrapperHeight"] = $wrapper_height;
      $jsConfigArray[$wrapper_id]["labelDisplay"] = $label_display;
      $jsConfigArray[$wrapper_id]["labelVerticalAlign"] = $label_vertical_align;
          
      // Add to our CSS markup value...
      $css_markup .= "
            
      #$wrapper_id{        
        top: $pos_top;
        left: $pos_left; 
      }
      ";
      
      // We do not want to try to resize any input fields if this
      // is the buttons wrapper.  Otherwise it will mess up our buttons.
      // This usually happens when you have CAPTCHA installed.
      if ($width != "0px" && $element_type != "") {
        $css_markup .= "        
        #$wrapper_id $element_type.form-text, 
        #$wrapper_id $element_type.form-textarea {
          width: $width;
          height: $height;
        }
          ";
      }
      
      // Handle any configurations which were set in the configure dialog.
      if ($wrapper_width != "") {
        $css_markup .= "#$wrapper_id { width: $wrapper_width; } ";
      }
      if ($wrapper_height != "") {
        $css_markup .= "
          #$wrapper_id { height: $wrapper_height; } 
          #$wrapper_id fieldset { height: 100%; } 
        ";
      }
      if ($label_display != "") {
        $css_markup .= "
          #$wrapper_id .form-item label { 
            vertical-align: $label_vertical_align; 
          }
          #$wrapper_id .form-item > input, 
          #$wrapper_id .form-item > label,
          #$wrapper_id .form-item > div,
          #$wrapper_id .form-item > div.form-radios > div,
          #$wrapper_id .form-item > div.form-checkboxes > div
          {
            display: $label_display;
          }
          
          #$wrapper_id .form-item div.ui-resizable-handle,
          #$wrapper_id .form-item div.description
          {
            display: block;
          }                          
                ";
      }
    }
    
    drupal_add_js(array("arrangeFieldsDialogConfigObj" => $jsConfigArray), "setting");
    
    if ($GLOBALS["arrange_fields_editing"] != $form_id) {
      // Meaning, we are not currently arranging this form.  The user
      // must actually be putting data into it on the node/edit page.  
      // Let's remove the extra
      // styles around the various divs so that it looks more natural.
      $css_markup .= "
      
      .arrange-fields-container {
        border: 0;
        background: none;
      }
      
      .arrange-fields-container .draggable-form-item {
        border: 0;
        background-color: transparent;
      }
      
      ";
    }
    
    // Now, add in our css markup...
    $form["arrange_fields_css_markup"] = array(
      "#value" => "<style>$css_markup</style>",
      "#after_build" => array("arrange_fields_add_form_css_js"),  // important if the form fails validation, we still get the CSS and JS added in.
    );
    
    // Let's add our modified form back to the cache (needed to get the preview
    // button to work correctly).
    form_set_cache($form["#build_id"], $form, $form_state);
    
  }
  
  
  // The user is trying to configure a field, and we want to show
  // it to them in the custom popup.  When they submit that form, we don't
  // want it to go to CCK's normal destination, so we set it to our
  // other popup function.
  if ($form_id == "content_field_edit_form" && $GLOBALS["arrange_fields_editing_field"] == TRUE) {
    $form["#redirect"] = "arrange-fields/popup-close-window";
  }
  
  
  
}

/**
 * This function simply adds the CSS and JS files we need when on the node/edit page.
 * I have to do it this way (and set this function in an #after_build on the form)
 * in order to make sure this still gets called, even if the form fails validation.
 *
 */
function arrange_fields_add_form_css_js($element) {
  drupal_add_css(drupal_get_path("module", "arrange_fields") . "/css/arrange_fields.css");    
  drupal_add_js(drupal_get_path("module", "arrange_fields") . "/js/arrange_fields_node_edit.js");    
  
  return $element;
  
}


/**
 * This is the "main menu" for arrange_fields.  Simply displays a list of
 * content types or webforms the user may arrange the fields of.
 *
 * @return string
 */
function arrange_fields_display_main() {
  $rtn = "";
  
  drupal_add_css(drupal_get_path("module", "arrange_fields") . "/css/arrange_fields.css");    
  
  $rtn .= t("Select a content type to arrange fields") . "...
          <ul>";
  
  foreach (node_get_types() as $type) {
      $rtn .= "<li>" . l($type->name, "arrange-fields/$type->type") . "</li>";
  }
  
  $rtn .= "</ul>";
  
  // If webform has been installed, attempt to use any available webforms as well.
  if ($GLOBALS["arrange_fields_webform_installed"]) {
    $rtn .= t("Select a webform to arrange fields") . "...
          <ul>";
    $is_empty = TRUE;
    $result = db_query("SELECT * FROM {node} WHERE type = 'webform'");
    $nodes = array();
    while ($node = db_fetch_object($result)) {
      $nodes[] = $node;
      $is_empty = FALSE;
    }
    
    if ($is_empty) {
      $rtn .= "<li>" . t("No webforms have been created yet.") . "</li>";
    }
    else {
      foreach($nodes as $node_res) {
        
        $rtn .= "<li>" . l($node_res->title, "arrange-fields/webform/$node_res->nid") . "</li>";
        
      }
    }
    
    $rtn .= "</ul>";
  }
  
  // Does the user have any additional form_id's specified they'd like to try
  // to arrange?
  $other_form_ids = trim(variable_get("arrange_fields_other_form_ids", ""));
  if ($other_form_ids != "") {
    $temp = explode("\n", $other_form_ids);
    $rtn .= t("Additional form_id's you specified on the Settings tab...");
    $rtn .= "<ul>";
    foreach($temp as $form_id) {
      $rtn .= "<li>" . l($form_id, "arrange-fields/other/$form_id") . "</li>";
    }
    $rtn .= "</ul>";
    $rtn .= "<div class='arrange-fields-other-form-caveat'>";
    $rtn .= t("Some caveats: Arrange Fields may not work correctly on forms
              with complex structures.  Also, remember that some forms may
              appear differently depending on if you are admin, an authorized user,
              or an anonymous user (like user_register).
              If you need to arrange a form which only appears for anonymous users,
              temporarily grant anonymous users the \"administer
              arrange fields\" permission so you can arrange the form how it
              needs to look.  Just be sure to take this away when you are done as
              it introduces a major security risk.");
    $rtn .= "</div>";
  }
  
  
  return $rtn;
}


function arrange_fields_init() {
  // is webform installed?
  if (function_exists("webform_menu")) {
    $GLOBALS["arrange_fields_webform_installed"] = TRUE;
  }
    
}

/**
 * Simple function, which should only appear on IE browsers.  It will
 * warn the user that some of the jQuery functions involved might have problems
 * in IE, and advises them to switch to a different browser when arranging fields.
 *
 */
function arrange_fields_render_ie_warning() {
  
  // Since the IE bug seems to be fixed for now, we will not render anything at all.
  // I want to leave this function in existence, just in case I need to use
  // it again one day.
  
  return "";
  
  $rtn = "<!--[if IE]>
  <div style='color: red; font-size: 0.9em; line-height: 1.1em;' id='arrange-fields-ie-warning'><b>Note for IE users:</b>
      For reasons that are currently unknown to me, the jQuery UI resizable() function
      does not work correctly in some installations of IE.  If you
      receive javascript errors while arranging fields, please try switching
      to a different browser, like Firefox or Chrome.  
      These IE problems will not
      affect IE visitors to your site, only YOU while you are arranging fields!
      <br>PS: if you figure out how to fix these errors, please open an issue at
      http://drupal.org/project/arrange_fields
   </div>
  <![endif]-->";
  
  return $rtn;
  
}


/**
 * This function displays the arrangement form, where the user will be able
 * to actually drag and drop to arrange fields.  In it, we actually load the
 * form which they are arranging, but we will be saving our data to
 * our own form.
 *
 * @param string $form_type
 * @return string
 */
function arrange_fields_display_form($form_type) {

  drupal_set_title("Arrange fields - $form_type");
  $rtn = "";
    
  $form_id = $form_type . "_node_form";
  $position_data = variable_get("arrange_fields_position_data_$form_id", FALSE);
  if ($position_data) {
    // Meaning, we have position data already for this form, so it is NOT
    // a brand-new form.  So, we should not pass "true" to the javascript
    // function arrangeFieldsRepositionToGrid.  Let's add a drupal
    // setting so we know that is the case.
    drupal_add_js(array("arrangeFieldsNotNewForm" => TRUE), "setting");
  }
  
  arrange_fields_add_arrange_css_js();  
  
  
  // We want to get the form which will let us save the position
  // information.  
  $rtn .= drupal_get_form("arrange_fields_position_form", $form_id, $form_type);

  $rtn .= arrange_fields_render_ie_warning();
  $rtn .= "<div>" . t("Use this form to drag-and-drop fields into the order which
          you want them to appear on the node/edit page.") . "</div>
          <div>" . t("You may resize text fields by dragging the right side
              of the field.") . "</div>";

  // The form we will be rearranging...
  $GLOBALS["arrange_fields_editing"] = $form_id;
  $GLOBALS["arrange_fields_editing_type"] = $form_type;
  
  $node_form = new stdClass();
  $node_form->type = $form_type;
  $rtn .= drupal_get_form($form_id, $node_form);

  $rtn .= "<div>" . t("If you need more room, move a field close to the bottom.  The
          container will resize, adding more room.") . "</div>";
  
  $rtn .= arrange_fields_render_config_dialog();
  
  return $rtn;
}


/**
 * Renders a div which will be used as the "config" dialog, displayed using
 * jQuery's .dialog() function.  It will let the administrator manage
 * details of a field, like width and height of the wrapper.
 *
 */
function arrange_fields_render_config_dialog() {
  
  $rtn = "";
  
  $rtn .= "<div id='arrange-fields-config-dialog' title='Configure'>
            <table>
              <tr>
                <td width='45%'>Wrapper width:</td><td><input type='input' name='af-dialog-width' size='6'></td>
              </tr>
              <tr> 
                <td>Wrapper height:</td><td><input type='input' name='af-dialog-height' size='6'></td>
              </tr>
            </table>
            <div style='font-size: 0.8em; line-height: 1.0em;'>(remember to specify px, %, etc. Leave blank for default.)</div>
            <br>
            Label: 
            <label><input type='radio' name='af-dialog-label-display' value='' checked> default (block)</label>
            <label><input type='radio' name='af-dialog-label-display' value='inline-block' > inline</label>
            
            
                  
            
           </div>";
  
  
  return $rtn;
  
}


/**
 * Similar function as arrange_fields_display_form,
 * but this is specifically for webforms (with the webform module). 
 *
 */
function arrange_fields_display_webform($nid) {

  $webform_node = node_load($nid);
  $form_id = "webform_client_form_$nid";
  $form_type = "webform";
  
  drupal_set_title("Arrange fields - webform - $webform_node->title");
  $rtn = "";
    
  $position_data = variable_get("arrange_fields_position_data_$form_id", FALSE);
  if ($position_data) {
    // Meaning, we have position data already for this form, so it is NOT
    // a brand-new form.  So, we should not pass "true" to the javascript
    // function arrangeFieldsRepositionToGrid.  Let's add a drupal
    // setting so we know that is the case.
    drupal_add_js(array("arrangeFieldsNotNewForm" => TRUE), "setting");
  }
  
  arrange_fields_add_arrange_css_js();
  
  // We want to get the form which will let us save the position
  // information.  
  $rtn .= drupal_get_form("arrange_fields_position_form", $form_id, $form_type);

  $rtn .= arrange_fields_render_ie_warning();
  $rtn .= "<div>" . t("Use this form to drag-and-drop fields into the order which
          you want them to appear on the webform entry page.") . "</div>
          <div>" . t("You may resize text fields by dragging the right side
              of the field.") . "</div>";

  // The form we will be rearranging...
  $GLOBALS["arrange_fields_editing"] = $form_id;
  $GLOBALS["arrange_fields_editing_type"] = $form_type;
  
  $rtn .= drupal_get_form($form_id, $webform_node, null, true);

  $rtn .= "<div>" . t("If you need more room, move a field close to the bottom, then save positions.  The
          container will resize, adding more room.") . "</div>";
  
  $rtn .= arrange_fields_render_config_dialog();
  
  return $rtn;
}


/**
 * Meant to be called by the display_form functions, this will make sure
 * the necessary module inc's are loaded, and the required js and css files
 * are added for the actual arranging of fields.
 *
 */
function arrange_fields_add_arrange_css_js() {

  module_load_include('inc', 'node', 'node.pages');
  jquery_ui_add(array('ui.draggable', 'ui.dialog', 'ui.resizable'));
  drupal_add_js(drupal_get_path("module", "arrange_fields") . "/js/arrange_fields_node_edit.js");  // must be included first.
  drupal_add_js(drupal_get_path("module", "arrange_fields") . "/js/arrange_fields.js");    
  drupal_add_css(drupal_get_path("module", "arrange_fields") . "/css/arrange_fields.css");    

}


/**
 * Similar function as arrange_fields_display_form,
 * but this is specifically for other, more generic forms
 * on the system.  For example, user_register, or custom
 * forms which a developer has written.
 *
 */
function arrange_fields_display_otherform($form_id) {

  $form_type = "otherform";
  
  drupal_set_title("Arrange fields - Other Forms - $form_id");
  $rtn = "";
    
  $position_data = variable_get("arrange_fields_position_data_$form_id", FALSE);
  if ($position_data) {
    // Meaning, we have position data already for this form, so it is NOT
    // a brand-new form.  So, we should not pass "true" to the javascript
    // function arrangeFieldsRepositionToGrid.  Let's add a drupal
    // setting so we know that is the case.
    drupal_add_js(array("arrangeFieldsNotNewForm" => TRUE), "setting");
  }
  
  arrange_fields_add_arrange_css_js();
  
  // We want to get the form which will let us save the position
  // information.  
  $rtn .= drupal_get_form("arrange_fields_position_form", $form_id, $form_type);

  $rtn .= arrange_fields_render_ie_warning();
  $rtn .= "<div>" . t("Use this form to drag-and-drop fields into the order which
          you want them to appear on the form entry page.") . "</div>
          <div>" . t("You may resize text fields by dragging the right side
              of the field.") . "</div>";

  // The form we will be rearranging...
  $GLOBALS["arrange_fields_editing"] = $form_id;
  $GLOBALS["arrange_fields_editing_type"] = $form_type;
  
  $rtn .= drupal_get_form($form_id);

  $rtn .= "<div>" . t("If you need more room, move a field close to the bottom, then save positions.  The
          container will resize, adding more room.") . "</div>";
  
  $rtn .= arrange_fields_render_config_dialog();
  
  return $rtn;
}


/**
 * This is the form which we will use to store the position data for the fields.
 *
 * @param array $form_state
 * @param string $form_id
 * @param string $form_type
 * @return array
 */
function arrange_fields_position_form($form_state, $form_id, $form_type) {
  $form = array();

  $form["arrange_fields_form_id"] = array(
    "#type" => "hidden",
    "#value" => $form_id,
  );

  $form["arrange_fields_form_type"] = array(
    "#type" => "hidden",
    "#value" => $form_type,
  );
  
  // This field ends up being hidden in CSS.
  $form["arrange_fields_position_data"] = array(
    "#type" => "textarea",
  );
  
  $form["save"] = array(
    "#type" => "submit",
    "#value" => "Save position data",
    "#attributes" => array("onClick" => "return arrangeFieldsSavePositions()"),
  );
  
  $form["reset"] = array(
    "#type" => "button",
    "#value" => "Reset position data",
    "#attributes" => array("onClick" => "return arrangeFieldsConfirmReset()"),
  );
  
  
  return $form;
}


/**
 * The primary purpose of this validator is to find out of the user is trying
 * to reset the form (and restore the form to its orignal state).
 *
 */
function arrange_fields_position_form_validate($form, $form_state) {

  $form_id = $form_state["values"]["arrange_fields_form_id"];
  if (stristr($form_state["values"]["op"], "reset")) {
    variable_set("arrange_fields_position_data_$form_id", "");
    drupal_set_message(t("Position data for this form has been reset.  It will 
                      be displayed to the user without any modifications,
                      in its original state."));
    
    // Need to refresh the page in order for the positions to be
    // fully reset.
    $path = isset($_GET['q']) ? $_GET['q'] : '<front>';
    $link = url($path, array('absolute' => TRUE));
    drupal_goto($link);    
  }
}

/**
 * We will save the position data into a variable using variable_set.
 *
 */
function arrange_fields_position_form_submit($form, $form_state) {
  $form_id = $form_state["values"]["arrange_fields_form_id"];
  $form_type = $form_state["values"]["arrange_fields_form_type"];
  $position_data = $form_state["values"]["arrange_fields_position_data"];
 
  variable_set("arrange_fields_position_data_$form_id", $position_data);
  
  $demo_link = l(t("See demo of most recent save (loads in new window)"), "node/add/" . str_replace("_", "-", $form_type), array("attributes" => array("target" => "_blank")));
  if ($form_type == "webform") {
    $nid = str_replace("webform_client_form_", "", $form_id);
    $demo_link = l(t("See demo of most recent save (loads in new window)"), "node/$nid", array("attributes" => array("target" => "_blank")));
  }
  
  if ($form_type == "otherform") {
    $demo_link = "";
  }
  
  drupal_set_message(t("Position data saved.") . " " . $demo_link);
}


/**
 * Theme registry alter hook
 * 
 * Register this modules path as a search location for tpl files.
 * We want it to look for the special popup page.tpl file in the module's
 * directory.
 *
 */
function arrange_fields_theme_registry_alter(&$theme_registry) {
  if (is_array($theme_registry['page'])) {
    // store a reference to the first theme path entry (normally this should be 'modules/system')
    $first_path = array_shift($theme_registry['page']['theme paths']);
    
    // get the path to our module's page template files
    $template_path = drupal_get_path('module', 'arrange_fields');
    
    // now change the array to have the first entry first, then our template path, and then any other theme paths
    array_unshift($theme_registry['page']['theme paths'], $first_path, $template_path);
  }
  
}

